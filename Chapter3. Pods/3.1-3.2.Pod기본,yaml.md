# Pod 기본, yaml

다음은 3.1 \~ 3.2 chapter 의 내용들을 요약한 내용입니다.



# Pod 설계 원칙

Pod 과 Pod 내에 Container 들을 구성할때 주요 원칙은 다음과 같습니다.



**컨테이너 사용 원칙**

1. ✅ **컨테이너당 하나의 프로세스** (자식 프로세스 제외)
2. ❌ **하나의 컨테이너에 여러 관련 없는 프로세스 실행 금지**



**Pod 구성 원칙**

1. ✅ **독립적인 구성 요소는 별도의 Pod로**
2. ✅ **밀접하게 결합된 프로세스만 같은 Pod에**
3. ✅ **개별 스케일링이 필요하면 별도의 Pod로**



**쿠버네티스에서의 스케일링 단위** 

- Pod 는 스케일링의 기본 단위입니다.
- 개별 컨테이너를 수평으로 스케일링할수 없습니다.



Pod 에서 여러 컨테이너를 사용하는 경우 (Sidecar)

- 여러 컨테이너를 단일 Pod에 배치하는 주된 이유는 **애플리케이션이 하나의 주요 프로세스와 하나 이상의 보조 프로세스로 구성되는 경우**입니다.



| 특성                  | 설명                                                         |
| --------------------- | ------------------------------------------------------------ |
| **스케일링 단위**     | Kubernetes는 개별 컨테이너를 수평으로 스케일링할 수 없고 전체 Pod를 스케일링 |
| **비효율적 스케일링** | Pod가 프론트엔드와 백엔드 컨테이너로 구성되어 있고 Pod 인스턴스 수를 2개로 스케일 업하면, 프론트엔드 컨테이너 2개와 백엔드 컨테이너 2개가 생김 |
| **다른 요구사항**     | 일반적으로 프론트엔드 구성 요소는 백엔드와 완전히 다른 스케일링 요구사항이 있음 |
| **백엔드의 특성**     | 데이터베이스와 같은 백엔드는 (무상태) 프론트엔드 웹 서버에 비해 스케일링하기 훨씬 어려움 |



<br/>



다음 내용은 클로드가 그려준 의사결정 플로우 차트인데 직관적으로 잘 설명하고 있는 것 같아서 가져왔습니다.

```
질문 시작
    │
    ▼
┌───────────────────────────────┐
│ 같은 머신에서 실행되어야 하는가? │
└───────────────────────────────┘
    │
    ├─── 예 ──► ┌──────────────────────────┐
    │           │ 하나의 논리적 앱인가?      │
    │           └──────────────────────────┘
    │               │
    │               ├─── 예 ──► ┌─────────────────────────┐
    │               │           │ 함께 스케일링되어야 하는가?│
    │               │           └─────────────────────────┘
    │               │               │
    │               │               ├─── 예 ──► 같은 Pod ✓
    │               │               │
    │               │               └─── 아니오 ──► 별도 Pod ✓
    │               │
    │               └─── 아니오 ──► 별도 Pod ✓
    │
    └─── 아니오 ──► 별도 Pod ✓
```

<br/>



## 왜 여러 컨테이너가 하나의 컨테이너보다 나은가?

여러 프로세스를 하나의 컨테이너에서 실행한다면, 흔히 말하는 IPC (Inter Process Communication) 을 통해 프로세스 간 통신을 하게 됩니다. 컴퓨터 공학/컴퓨터 과학을 전공한다면 한번씩 다뤄봤을 리눅스 소켓 프로그래밍을 하면서 접해봤을 내용인데, kubernetes 에서는 컨테이너 내에서 이렇게 프로세스간 통신을 하는 것은 지양해야 하는 방식입니다.<br/>

Kubernetes 에서는 항상 컨테이너에서 프로세스를 실행하고, 각각의 컨테이너는 "격리된 머신" 으로 생각해야 합니다.<br/>



## 컨테이너는 단일 프로세스를 위해 설계되었습니다.

컨테이너는 단일 프로세스를 위해 설계되었습니다. 컨테이너는 컨테이너당 하나의 프로세스만 실행하도록 설계되었습니다.

따라서 컨테이너 내에서 여러 프로세스를 실행하는 것은 가급적 지양해야 합니다.

하나의 컨테이너 내에서 여러 프로세스를 실행할 경우 다음과 같은 문제가 발생합니다.

- **프로세스 관리의 책임**: 모든 프로세스를 계속 실행 상태로 유지해야 하는 책임이 있습니다
- **로그 관리의 어려움**: 모든 프로세스가 동일한 표준 출력으로 로그를 남기므로 어떤 프로세스가 무엇을 로그했는지 파악하기 어렵습니다
- **자동 복구 메커니즘**: 프로세스가 크래시될 때 자동으로 재시작하는 메커니즘을 직접 포함해야 합니다

<br/>



```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
❌ 안티패턴: 독립적인 프로세스를 하나의 Pod에
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌───────────────────────────────┐
│           Pod                 │
│                               │
│  ┌────────────┐ ┌──────────┐ │
│  │ Frontend   │ │ Backend  │ │
│  │ container  │ │ container│ │
│  │┌─────────┐ │ │┌────────┐│ │
│  ││Frontend │ │ ││Backend ││ │
│  ││process  │ │ ││process ││ │
│  │└─────────┘ │ │└────────┘│ │
│  └────────────┘ └──────────┘ │
└───────────────────────────────┘

문제점:
- 리소스 활용 비효율
- 개별 스케일링 불가
- 불필요한 결합
```

<br/>



## e.g. 다중 계층 앱 (frontend/backend)

frontend, backend 를 하나의 파드 내에 각각의 컨테이너로 하나로 묶어서 구성하는 것은 좋지 못한 선택입니다. 

이유는 다음과 같습니다.



(1) 리소스 활용의 비효율성 

- 리소스를 골고루 사용하지 못하게 되는데, 예를 들면 (아래 그림) 클러스터 내에 노드가 2개 있을때 파드 하나만 노드 하나로 배포되게 되므로, backend, frontend 모두 1개의 워커노드의 리소스만 사용하게 되어 다른 나머지 1개의 워커노드는 놀고 있는 상태가 됩니다.

(2) 개별 스케일링을 위한 분리

- frontend 의 부하가 높아서 frontend 의 스케일아웃을 진행하려 할때 같은 파드 내의 backend 도 같이 스케일아웃 됩니다.



> 출쳐 : Claude

```
❌ 잘못된 방법: 하나의 Pod에 프론트엔드와 백엔드

┌──────────────────────────────────┐
│ 2-Node Kubernetes Cluster        │
│                                  │
│  Node 1 (사용 중)                 │
│  ┌────────────────────────────┐  │
│  │ Pod                        │  │
│  │ ┌──────────┐ ┌──────────┐ │  │
│  │ │Frontend  │ │Database  │ │  │
│  │ └──────────┘ └──────────┘ │  │
│  └────────────────────────────┘  │
│                                  │
│  Node 2 (유휴 상태) 💤            │
│  리소스 낭비!                      │
└──────────────────────────────────┘

✅ 올바른 방법: 별도의 Pod로 분리

┌──────────────────────────────────┐
│ 2-Node Kubernetes Cluster        │
│                                  │
│  Node 1                          │
│  ┌────────────────────────────┐  │
│  │ Frontend Pod               │  │
│  │ ┌──────────┐               │  │
│  │ │Frontend  │               │  │
│  │ └──────────┘               │  │
│  └────────────────────────────┘  │
│                                  │
│  Node 2                          │
│  ┌────────────────────────────┐  │
│  │ Database Pod               │  │
│  │ ┌──────────┐               │  │
│  │ │Database  │               │  │
│  │ └──────────┘               │  │
│  └────────────────────────────┘  │
│                                  │
│  모든 리소스 활용! ✓               │
└──────────────────────────────────┘
```

<br/>



frontend 와 backend 처럼 다중 계층 앱이 존재할 경우 다음과 같이 별도의 Pod 로 분리해주는 것이 좋습니다.

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ 올바른 패턴: 별도의 Pod로 분리
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌─────────────────┐     ┌─────────────────┐
│ Frontend Pod    │     │ Backend Pod     │
│                 │     │                 │
│  ┌───────────┐  │     │  ┌───────────┐  │
│  │ Frontend  │  │     │  │ Backend   │  │
│  │ container │  │     │  │ container │  │
│  │┌────────┐ │  │     │  │┌────────┐ │  │
│  ││Frontend│ │  │     │  ││Backend │ │  │
│  ││process │ │  │     │  ││process │ │  │
│  │└────────┘ │  │     │  │└────────┘ │  │
│  └───────────┘  │     │  └───────────┘  │
└─────────────────┘     └─────────────────┘

장점:
- 독립적인 스케일링 ✓
- 효율적인 리소스 활용 ✓
- 독립적인 배포 및 업데이트 ✓
- 장애 격리 ✓
```







## Sidecar 패턴

![](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d8/NSU_601_OSL_Steib.jpg/500px-NSU_601_OSL_Steib.jpg)

> 출처 : https://en.wikipedia.org/wiki/Sidecar



여러 컨테이너를 단일 Pod에 배치하는 경우 주로 Sidecar 패턴을 통해 이뤄지게 됩니다. **애플리케이션이 하나의 주요 프로세스와 하나 이상의 보조 프로세스로 구성되는 경우** 다음과 같이 여러 컨테이너로 이뤄집니다.

```
┌─────────────────────────────────────────┐
│              Pod                        │
│                                         │
│  ┌────────────────────────────────┐    │
│  │     Main container             │    │
│  │   (웹 서버)                     │    │
│  │   - 파일 제공                   │    │
│  │   - HTTP 요청 처리              │    │
│  └────────────────────────────────┘    │
│                  │                      │
│                  │ 공유                 │
│                  ▼                      │
│            ┌─────────┐                  │
│            │ Volume  │                  │
│            │ (/data) │                  │
│            └─────────┘                  │
│                  ▲                      │
│                  │ 공유                 │
│  ┌───────────────┴──────────────┐      │
│  │                              │      │
│  │  ┌──────────────┐  ┌──────────────┐│
│  │  │ Supporting   │  │ Supporting   ││
│  │  │ container 1  │  │ container 2  ││
│  │  │ (사이드카)    │  │ (로그 수집기) ││
│  │  │              │  │              ││
│  │  │ - 콘텐츠 다운 │  │ - 로그 수집   ││
│  │  │ - 파일 저장   │  │ - 로그 전송   ││
│  │  └──────────────┘  └──────────────┘│
│  └──────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

<br/>



## Sidecar 패턴을 사용하는 예

**예시 1: 웹 서버 + 콘텐츠 업데이터**

- **메인 컨테이너**: 특정 파일 디렉토리에서 파일을 제공하는 웹 서버
- **사이드카 컨테이너**: 주기적으로 외부 소스에서 콘텐츠를 다운로드하여 웹 서버의 디렉토리에 저장



**기타 사이드카 컨테이너의 예:**

- 로그 로테이터 및 수집기
- 데이터 프로세서
- 통신 어댑터
- 모니터링 에이전트
- 프록시



디스크에 무언가를 쓰거나 추가하는 로깅 작업 등과 같은 경우 Pod 간에 PV, PVC 를 구성할 필요 없이 Pod 내에서 컨테이너 끼리 EmptyDir 을 통해서 공유하는 것이 더 효율적인 경우가 있는데 이렇게 구성합니다.



```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✅ 예외: 밀접하게 결합된 컨테이너는 같은 Pod에
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌──────────────────────────────────┐
│           Pod                    │
│                                  │
│  ┌────────────────────────────┐ │
│  │  Main: Web Server          │ │
│  │  Port: 8080                │ │
│  └────────────────────────────┘ │
│              │ 공유               │
│              ▼                   │
│        ┌─────────┐               │
│        │ Volume  │               │
│        └─────────┘               │
│              ▲                   │
│  ┌───────────┴────────────────┐ │
│  │  Sidecar: Content Updater  │ │
│  │  - 주기적 콘텐츠 다운로드    │ │
│  └────────────────────────────┘ │
└──────────────────────────────────┘

사용 시기:
- 메인 프로세스 + 보조 프로세스
- 공유 파일 시스템 필요
- 동일한 네트워크 네임스페이스 필요
- 항상 같은 노드에서 실행 필요
```



# yaml 디스크립터

pod 을 정의하는 yaml 을 통해 정의하는데, 이 것을 책에서는 "yaml 디스크립터"라는 용어로 언급합니다.

yaml 형식의 주요 부분은 다음과 같이 구성됩니다.

1\. Metadata (메타데이터)

- Pod의 이름, 네임스페이스, 레이블, 기타 정보 포함

2\. Spec (사양)
- Pod의 실제 내용 설명
- 컨테이너 목록, 볼륨 등의 데이터

3\. Status (상태)
- 실행 중인 Pod의 현재 정보
- Pod의 상태, 각 컨테이너의 설명과 상태
- Pod의 내부 IP 및 기본 정보



Status 의 경우 사용자/개발자/운영자가 정의하는 영역이 아닙니다. kubectl edit pod 등의 명령을 통해 편집 시에 kubernetes 가 기록한 내용을 확인할수 있습니다. 사용자/개발자/운영자가 주요하게 수정하게 되는 영역은 metadata, spec 영역 입니다.



```yaml
apiVersion: v1              # Kubernetes API v1 버전에 부합
kind: Pod                   # Pod 리소스를 설명
metadata:
  name: kubia-manual        # Pod의 이름
spec:
  containers:
  - image: luksa/kubia      # 컨테이너를 생성할 이미지
    name: kubia             # 컨테이너의 이름
    ports:
    - containerPort: 8080   # 앱이 수신하는 포트
      protocol: TCP
```



- **apiVersion: v1**: Kubernetes API 버전
- **kind: Pod**: 리소스 타입은 Pod
- **metadata.name**: Pod 이름은 kubia-manual
- **spec.containers**: 단일 컨테이너 구성
  - **image**: luksa/kubia 이미지 기반
  - **name**: 컨테이너 이름은 kubia
  - **ports**: 포트 8080에서 수신



## containerPort

```yaml
apiVersion: v1              # Kubernetes API v1 버전에 부합
kind: Pod                   # Pod 리소스를 설명
metadata:
  name: kubia-manual        # Pod의 이름
spec:
  containers:
  - image: luksa/kubia      # 컨테이너를 생성할 이미지
    name: kubia             # 컨테이너의 이름
    ports:
    - containerPort: 8080   # 앱이 수신하는 포트 ## (1)
      protocol: TCP
```

위에서 살펴봤던 yaml 중에서 `containerPort` 섹션에 대한 내용은 (1) 에 해당되는 부분입니다.

`containerPort` 를 사용하는 이유는 다음의 이유가 있습니다.



(1) 문서화 목적 (정보 제공을 위해)

```
kubectl get pod kubia-manual -o yaml
# 이렇게 조회했을 때 어떤 포트를 사용하는지 바로 확인 가능
```



(2) 포트에 이름 부여

```plain
ports:
- containerPort: 8080
  name: http          # 이름을 지정하면
  protocol: TCP
- containerPort: 8443
  name: https
  protocol: TCP
```

이렇게 포트에 이름을 부여하면 Service 에서 포트번호 대신 이름을 통해 접근할수 있는데 Pod 내에서 포트번호를 변경해도 서비스 내에서는 해당 Container 의 포트 이름으로 지정해둔 상태라면, 서비스내에서 포트번호까지 수정하지 않아도 된다는 장점이 있습니다.

```yaml
apiVersion: v1
kind: Service
spec:
  ports:
  - name: http
    port: 80
    targetPort: http    # 포트 번호 대신 이름 사용!
```

<br/>



containerPort 는 다음과 같이 명령어로 변경하는 것 역시 가능합니다. 

```bash
kubectl set container-port deployment/front-end nginx=80 -n spline-reticulator
```

<br/>



# 주요 명령어 (kubectl)

## kubectl explain

kubectl explain 은 Pod 리소스의 구조와 각 필드의 의미를 **문서처럼 조회**할 수 있는 명령어입니다.

e.g.

```bash
# Pod에 대한 기본 설명 보기
$ kubectl explain pods

DESCRIPTION:
  Pod is a collection of containers that can run on a host...

FIELDS:
  kind <string>
    Kind is a string value representing the REST resource...
  
  metadata <Object>
    Standard object's metadata...
  
  spec <Object>
    Specification of the desired behavior of the pod...
  
  status <Object>
    Most recently observed status of the pod...
```



e.g.

```bash
# 특정 속성에 대해 더 깊이 파고들기
$ kubectl explain pod.spec

RESOURCE: spec <Object>

DESCRIPTION:
  Specification of the desired behavior of the pod...
  podSpec is a description of a pod.

FIELDS:
  hostPID <boolean>
    Use the host's pid namespace. Optional: Default to false.
  
  containers <[]Object> -required-
    List of containers belonging to the pod. Containers cannot 
    currently be added or removed. There must be at least one 
    container in a pod. Cannot be updated.
  
  volumes <[]Object>
    List of volumes that can be mounted by containers 
    belonging to the pod.
```

<br/>



## kubectl create

pod 을 생성할때 kubectl create 를 통해 생성할 수 있으며, `-f` 는 파일명을 지정할 수 있습니다. kubectl create 는 pod 뿐만 아니라 쿠버네티스의 다른 종류의 리소스 들을 생성할때 사용되는 명령어입니다.

```bash
$ kubectl create -f kubia-manual.yaml
pod "kubia-manual" created
```





## kubectl get pod -o yaml

리소스 관리나 상태 조회시 자주 사용하는 명령어입니다. 외울필요까지는 없고 익숙해지게 됩니다.

```bash
$ kubectl get po kubia-manual -o yaml
```

<br/>



json 으로 조회하는 것도 가능합니다.

```bash
$ kubectl get po kubia-manual -o json
```

<br/>



트러블 슈팅시에는 주로 `-o yaml` 로 조회한 후에 파일 리디렉션을 통해 파일로 저장한 후 yq 를 통해 필요한 필드에 대해 어떤 값이 지정되어 있는지 등을 출력해서 확인하는 용도로 사용합니다. CKA 자격증을 준비한다면 yq 명령어에 익숙해지면, 배점높은 문제를 맞추기 좋습니다.





## kubectl get pods

다음은 default 네임스페이스에 등록된 pod 를 확인하는 명령어입니다.

```bash
$ kubectl get pods

NAME           READY   STATUS    RESTARTS   AGE
kubia-manual   1/1     Running   0          32s
kubia-zxzij    1/1     Running   0          1d
```

<br/>



만약 namespace 를 지정한다면 다음과 같이 `--namespace` 또는 `-n` 을 사용합니다.

```bash
$ kubectl get pods -n kubia

NAME           READY   STATUS    RESTARTS   AGE
kubia-manual   1/1     Running   0          32s
kubia-zxzij    1/1     Running   0          1d


$ kubectl get pods --namespace kubia

NAME           READY   STATUS    RESTARTS   AGE
kubia-manual   1/1     Running   0          32s
kubia-zxzij    1/1     Running   0          1d
```

<br/>



## kubectl logs

단일 컨테이너의 로그를 확인하는 명령어입니다.

```bash
$ kubectl logs kubia-manual

Kubia server starting...
```

파드 내에 컨테이너가 여러개라면, 파드 의 로그를 조회할 경우 내에 해당 컨테이너들 모두의 로그가 보입니다.<br/>

컨테이너 하나만 지정하고 싶을 경우 `-c` 옵션을 사용합니다.

```bash
$ kubectl logs kubia-manual -c kubia

Kubia server starting...
```

<br/>



## 로그 로테이션 

- 컨테이너 로그는 **매일** 자동으로 로테이션 됩니다.
- 로그 파일이 **10MB**에 도달할 때마다 로테이션 됩니다.
- `kubectl logs` 명령은 **마지막 로테이션 이후의 로그 항목만** 표시합니다.



## Pod 삭제 후에도 로그를 보고 싶다면

Pod 삭제 후에도 로그를 사용하고 싶다면 중앙 집중식 클러스터 전체 로깅 설정이 필요합니다. 이 경우 모든 로그를 중앙 저장소에 저장하게 되는데, 17장에서 자세히 설명합니다.



## kubectl expose, kubectl port-forward

### kubectl expose

pod 또는 deploy 를 외부로 노출하고 싶다면 다음의 명령어를 통해 서비스를 생성하면 됩니다. 아직 deploy(deployment) 에 대해서는 배우지 않았지만, 미리 한번 살펴보면 다음과 같은 방식을 통해 Service 로 노출하는 것이 가능합니다.

```bash
kubectl expose deploy -n spline-reticulator front-end \
  --port=80 --type=NodePort \
  --name=front-end-svc \
  --dry-run=client -o yaml > svc.yaml

kubectl apply -f svc.yaml
```

<br/>



### kubectl port-forward

```bash
$ kubectl port-forward kubia-manual 8888:8080

... Forwarding from 127.0.0.1:8888 -> 8080
... Forwarding from [::1]:8888 -> 8080
```

- `kubia-manual`: 대상 Pod 이름
- `8888`: 로컬 머신의 포트
- `8080`: Pod의 포트
- 로컬 머신의 포트 8888을 kubia-manual Pod의 포트 8080으로 전달



터미널에서는 다음과 같이 확인 가능합니다.

```bash
$ curl localhost:8888

You've hit kubia-manual
```

<br/>



curl localhost:8888 을 수행하면 다음과 같은 동작이 수행됩니다.

- curl이 localhost:8888로 HTTP 요청 전송
- kubectl port-forward 프록시가 요청을 Pod로 전달
- Pod의 애플리케이션이 응답 반환



<br/>



