# 3.7. 네임스페이스를 사용해 리소스 그룹화



1\. **네임스페이스의 목적**

   - 리소스를 논리적으로 그룹화
   - 멀티 테넌트 환경 지원
   - 리소스 이름 충돌 방지
   - 접근 제어 및 리소스 할당량 관리의 기반



2\. **네임스페이스 vs 레이블**

   - 레이블: 겹칠 수 있는 그룹, 유연한 조직
   - 네임스페이스: 중복되지 않는 분리된 그룹



3\. **네임스페이스 작업**

   - 생성: YAML 파일 또는 `kubectl create namespace` 명령
   - 리소스 관리: `-n` 또는 `--namespace` 플래그 사용
   - Context 전환으로 기본 네임스페이스 변경 가능



4\. **네트워크 격리**

   - 네임스페이스는 기본적으로 네트워크 격리를 제공하지 않음
   - NetworkPolicy 리소스로 명시적 격리 필요
   - 네트워킹 솔루션이 NetworkPolicy를 지원해야 함



<br/>



**네임스페이스를 사용하는 것의 장점들**

- 서로의 리소스를 실수로 수정/삭제하는 것 방지
- 이름 충돌 걱정 없음
- 네임스페이스가 리소스 이름의 범위(scope)를 제공



네임스페이스는 리소스 격리 외에도 다음과 같은 방식으로 사용할수 있다는 장점이 있습니다.

- 특정 사용자에게만 특정 리소스에 대한 접근 허용
- 개별 사용자가 사용할 수 있는 컴퓨팅 리소스 양 제한



<br/>



**네트워크 격리**<br/>

kubernetes 에서는 다양한 요소들에 대해 다음과 같은 방식으로 네트워크 격리를 논리적으로 제공할수 있는데, `namespaceSelector` 는 namespace 레벨로 리소스의 네트워크를 다른 리소스들과 논리적으로 구분지어 격리할 수 있습니다.

- **NetworkPolicy 리소스**를 사용하여 파드 간 네트워크 격리 구현 가능
- **podSelector**: 특정 파드만 접근 허용
- **namespaceSelector**: 특정 네임스페이스의 파드만 접근 허용
- **ipBlock**: 특정 IP 범위만 접근 허용
- **ingress 규칙**: 인바운드 트래픽 제어
- **egress 규칙**: 아웃바운드 트래픽 제어
- 네트워킹 솔루션이 NetworkPolicy를 지원해야 함



<br/>

networkpolicy 에서 네임스페이스를 사용하는 예제 역시 살펴볼 예정인데, 이번 문서에서는 아주 간략하게 networkpolicy 에서 namespace 를 통해 리소스 간 네트워크를 격리하는 예를 살펴봅니다.<br/>



실무 팁

- 시스템이 복잡해지면 네임스페이스로 조직화
- 환경별로 네임스페이스 분리 (dev, staging, prod)
- 팀별로 네임스페이스 분리
- 네트워크 보안이 필요하면 NetworkPolicy 설정
- 멀티 테넌트 환경에서는 네임스페이스 레이블 수정 권한 제한



<br/>



# kubernetes 기본 네임스페이스들

kubernetes 에서 기본으로 제공하는 네임스페이스들이 있는데 다음과 같습니다.

| 네임스페이스  | 용도                                                         |
| ------------- | ------------------------------------------------------------ |
| `default`     | 명시적으로 네임스페이스를 지정하지 않으면 사용되는 기본 네임스페이스 |
| `kube-public` | 모든 사용자가 읽을 수 있는 공개 네임스페이스                 |
| `kube-system` | Kubernetes 시스템 컴포넌트들이 위치하는 네임스페이스         |

<br/>



e.g. 

```bash
$ kubectl get ns
NAME        LABELS    STATUS    AGE
default     <none>    Active    1h
kube-public <none>    Active    1h
kube-system <none>    Active    1h
```

<br/>



# 주요 명령어 형식

## 조회

특정 네임스페이스의 리소스를 조회할 경우 `-n`, `--namespace` 옵션을 통해 해당 네임스페이스에 속한 리소스를 조회할 수 있습니다.

```bash
$ kubectl get po --namespace kube-system

# 또는 단축형
$ kubectl get po -n kube-system

NAME                                    READY   STATUS    RESTARTS   AGE
fluentd-cloud-kubia-e8fe-node-txje      1/1     Running   0          1h
heapster-v11-fz1ge                      1/1     Running   0          1h
kube-dns-v9-p8a4t                       0/4     Pending   0          1h
kube-ui-v4-kdlai                        1/1     Running   0          1h
l7-lb-controller-v0.5.2-bue96           2/2     Running   92         1h
```



## 생성

### e.g. yaml 파일로 정의** (Listing 3.6 - custom-namespace.yaml)

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: custom-namespace
```



**설명:**

- `kind: Namespace`: 네임스페이스를 정의하는 것을 명시
- `name: custom-namespace`: 네임스페이스의 이름


**적용**

```bash
$ kubectl create -f custom-namespace.yaml
namespace "custom-namespace" created
```

<br/>



### e.g. kubectl 로 생성

```bash
$ kubectl create namespace custom-namespace
namespace "custom-namespace" created
```



### e.g. kubectl → 파일 추출 → 적용

또는 다음과 같이 kubectl 로 생성하기 전에 yaml 파일로 만들고 적용하는 것 역시 가능합니다.

```bash
$ kubectl create namespace custom-namespace --dry-run=client -o yaml > ns.yaml
$ kubectl apply -f ns.yaml
```



### Tip

실무에서는 가급적 yaml 파일로 명세화 하는 것을 추천합니다. 버전관리 시스템과의 연동도 편하고, 이력관리가 되기 때문입니다.



## alias

네임스페이스 전환시 클러스터가 여러개일 경우 모든 명령어를 직접 치는 것이 오래 걸릴때가 있는데 다음과 같이 alias를 지정하면 네임스페이스 간 전환이 편리해집니다. `~/.bashrc`, `~/.zshrc` 등에 다음과 같이 정의하면 됩니다.

```bash
alias kcd='kubectl config set-context $(kubectl config current-context) --namespace '
```

<br/>



그리고 alias 는 다음과 같이 사용가능합니다.

```bash
kcd some-namespace
```

<br/>



# NetworkPolicy 와 Namespace 를 이용한 네트워크 격리 (13.4장)

네트워킹 솔루션이 지원하는 경우, **NetworkPolicy 리소스**를 사용하여 파드 간 네트워크를 보호할 수 있습니다. 만약 CNI 또는 네트워킹 솔루션이 NetworkPolicy 를 지원하지 않을경우 Network Policy 는 아무런 영향을 주지 못합니다.<br/>



네임스페이스는 기본적으로 네트워크 격리를 제공하지 않지만 NetworkPolicy 내에서는 다양한 리소스를 다음의 selector 를 통해 네트워크 격리를 제공할 수 있습니다.
- **NetworkPolicy 리소스**를 사용하여 파드 간 네트워크 격리 구현 가능
- **podSelector**: 특정 파드만 접근 허용
- **namespaceSelector**: 특정 네임스페이스의 파드만 접근 허용
- **ipBlock**: 특정 IP 범위만 접근 허용
- **ingress 규칙**: 인바운드 트래픽 제어
- **egress 규칙**: 아웃바운드 트래픽 제어
- 네트워킹 솔루션이 NetworkPolicy를 지원해야 함



## e.g. default-deny

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny
spec:
  podSelector: {}  # 빈 셀렉터 = 네임스페이스의 모든 파드에 적용
```

**설명:**
- 빈 파드 셀렉터(`{}`)는 같은 네임스페이스의 모든 파드와 매칭됩니다.
- 이 NetworkPolicy를 특정 네임스페이스에 생성하면, 해당 네임스페이스의 어떤 파드에도 연결할 수 없게 됩니다.



## e.g. 네임스페이스 내 특정 파드만 서버 파드에 연결 허용

클라이언트가 네임스페이스의 파드에 연결할 수 있도록 하려면, **명시적으로 누가 연결할 수 있는지** 지정해야 합니다.

<br/>



**예시 시나리오:**

- 네임스페이스 `foo`에 PostgreSQL 데이터베이스 파드 실행
- 데이터베이스를 사용하는 웹서버 파드 존재
- 다른 파드들은 데이터베이스에 연결하지 못하도록 차단

<br/>

**Listing 13.22 - network-policy-postgres.yaml:**

```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: postgres-netpolicy
spec:
  podSelector:
    matchLabels:
      app: database          # app=database 레이블을 가진 파드에 적용
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: webserver     # app=webserver 레이블을 가진 파드만 허용
    ports:
    - port: 5432             # 포트 5432로만 연결 허용
```

<br/>



**결과:**

- `app=webserver` 레이블을 가진 파드만 `app=database` 레이블을 가진 파드에 연결 가능
- 포트 5432로만 연결 가능
- 다른 파드는 데이터베이스 파드에 연결 불가
- 웹서버 파드도 5432 이외의 포트로는 연결 불가

<br/>



## e.g. 네임스페이스간 네트워크 격리

**시나리오:**
- 여러 테넌트가 같은 Kubernetes 클러스터 사용
- 각 테넌트는 여러 네임스페이스 사용 가능
- 각 네임스페이스에는 소속 테넌트를 명시하는 레이블이 있음
- 예: Manning 테넌트의 모든 네임스페이스는 `tenant: manning` 레이블 보유



**Listing 13.23 - network-policy-cart.yaml:**
```yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: shoppingcart-netpolicy
spec:
  podSelector:
    matchLabels:
      app: shopping-cart     # app=shopping-cart 레이블을 가진 파드에 적용
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          tenant: manning    # tenant=manning 레이블을 가진 네임스페이스만 허용
    ports:
    - port: 80
```

**결과:**
- `tenant: manning` 레이블이 있는 네임스페이스에서 실행되는 파드만 Shopping Cart 마이크로서비스에 접근 가능
- 다른 테넌트는 접근 불가
- NetworkPolicy가 namespaceSelector를 사용하여 특정 네임스페이스의 파드만 접근할 수 있도록 하는 모습을 보여줍니다.

- `tenant: manning` 레이블이 있는 네임스페이스(manningA, manningB)의 파드들은 shopping-cart 파드에 접근 가능
- 다른 네임스페이스(ecommerce-ltd)의 파드들은 접근 불가



**다른 테넌트에게 접근 허용:**
파트너 회사 등 다른 테넌트에게도 접근을 허용하려면:

- 추가 NetworkPolicy 리소스 생성
- 또는 기존 NetworkPolicy에 추가 ingress 규칙 추가

> **참고:** 멀티 테넌트 Kubernetes 클러스터에서는 테넌트가 자신의 네임스페이스에 레이블(또는 어노테이션)을 추가할 수 없어야 합니다. 그렇지 않으면 namespaceSelector 기반 ingress 규칙을 우회할 수 있습니다.



## e.g. CIDR 표기법을 이용한 격리

파드 셀렉터나 네임스페이스 셀렉터 대신 **CIDR 표기법으로 IP 블록**을 지정할 수도 있습니다.<br/>



**Listing 13.24 - network-policy-cidr.yaml:**
```yaml
ingress:
- from:
  - ipBlock:
      cidr: 192.168.1.0/24   # 192.168.1.1 ~ 192.168.1.255 범위만 허용
```

**결과:**
- shopping-cart 파드는 192.168.1.0/24 IP 블록의 클라이언트로부터만 접근 가능



<br/>



## e.g. 파드 집합의 아웃바운드 트래픽 제한

지금까지는 **ingress 규칙**을 사용하여 파드로 들어오는 인바운드 트래픽을 제한했습니다. **egress 규칙**을 사용하면 파드에서 나가는 아웃바운드 트래픽도 제한할 수 있습니다.



**Listing 13.25 - 아웃바운드 트래픽 제한 예시:**
```yaml
spec:
  podSelector:
    matchLabels:
      app: webserver
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: database
```

**결과:**
- `app=webserver` 레이블을 가진 파드는 `app=database` 레이블을 가진 파드로만 접근 가능
- 다른 파드나 IP(클러스터 내부 또는 외부 모두)로는 접근 불가





