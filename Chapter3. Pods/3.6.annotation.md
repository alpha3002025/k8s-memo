# 3.6. Annotation

✅ **어노테이션을 사용하는 경우:**
- 큰 데이터 블록 (최대 256KB)
- 도구나 라이브러리가 사용하는 메타데이터
- 설명, 담당자 정보, 빌드 정보
- 버전 정보, 의존성 정보
- 새로운 기능의 알파/베타 단계

❌ **레이블을 사용하는 경우:**
- 객체 식별 및 그룹화
- 레이블 셀렉터로 선택이 필요한 경우
- 짧고 간결한 정보
- Kubernetes 스케줄링, 서비스 라우팅 등



레이블과 어노테이션의 공통점

- 둘 다 key-value 쌍
- 둘 다 Pod 생성 시 또는 생성 후 추가 가능
- 둘 다 실행 중인 Pod에서 수정 가능



레이블과 어노테이션의 차이점

- 레이블은 **선택(selection)** 가능, 어노테이션은 불가능
- 레이블은 **짧은 정보**, 어노테이션은 **큰 정보** (최대 256KB)
- 레이블은 **식별 목적**, 어노테이션은 **보조 정보 목적**



<br/>



# 어노테이션의 주요 용도

1\. 자동으로 추가되는 어노테이션
- Kubernetes가 자동으로 특정 어노테이션을 객체에 추가
- 예: `kubernetes.io/created-by` - Pod를 생성한 객체 정보



2\. 사용자가 수동으로 추가하는 어노테이션

- Pod나 API 객체에 대한 설명 추가
- 객체를 생성한 사람의 이름 기록
- 협업을 위한 정보 제공
- 클러스터 작업자들이 개별 객체 정보를 빠르게 조회 가능



3\. 새로운 기능 도입 시 활용

- Kubernetes의 알파/베타 버전 기능은 처음에 API 객체에 새 필드를 추가하지 않음
- 대신 어노테이션을 사용하여 기능 테스트
- API 변경사항이 확정되면 새 필드로 전환하고 어노테이션은 deprecated됨



4\. 실용적 활용 사례 (베스트 프랙티스)

- 리소스에 대한 설명
- 담당자 연락처 정보
- 마이크로서비스 아키텍처에서 Pod가 사용하는 다른 서비스 이름 목록
- 서비스 간 의존성 표시
- 빌드 및 버전 정보
- 도구나 GUI를 위한 메타데이터 (아이콘 이름 등)



<br/>



# 명령어

어노테이션 조회

```bash
# YAML 전체 보기
kubectl get po <pod-name> -o yaml

# 간단한 정보 보기
kubectl describe pod <pod-name>
```

<br/>



어노테이션 추가/수정

```bash
# 어노테이션 추가
kubectl annotate pod <pod-name> <key>=<value>

# 예시
kubectl annotate pod kubia-manual mycompany.com/someannotation="foo bar"

# 기존 어노테이션 수정 (--overwrite 필요)
kubectl annotate pod <pod-name> <key>=<new-value> --overwrite
```

<br/>



어노테이션 삭제

```bash
# 어노테이션 삭제 (키 뒤에 - 붙임)
kubectl annotate pod <pod-name> <key>-
```

<br/>



# Best Practice

리소스에는 최소한 다음 어노테이션이 포함되어야 합니다.

- 리소스에 대한 설명
- 담당자 연락처 정보
- 마이크로서비스 아키텍처에서 Pod가 사용하는 다른 서비스 이름 목록
- 서비스 간 의존성 표시
- 빌드 및 버전 정보
- 도구나 GUI를 위한 메타데이터 (아이콘 이름 등)



e.g.

```yaml
metadata:
  annotations:
    description: "Frontend web service for user authentication"
    contact: "team-frontend@mycompany.com"
    dependencies: "auth-service, user-db-service, session-cache"
    version: "v2.3.1"
    build-info: "jenkins-build-#1234"
    icon: "web-icon.png"
```



이렇게하면 다음의 장점이 있습니다.

- Pod 간 의존성 시각화 가능
- 문제 발생 시 빠른 담당자 확인
- 버전 추적 및 롤백 용이



<br/>



# 네이밍 권장사항

**형식:** `도메인명/어노테이션-이름`

**예시:** `mycompany.com/someannotation`



이런 형태의 네이밍을 권장하는 이유는 다음과 같습니다.

1\. **키 충돌 방지**
- 서로 다른 도구나 라이브러리가 객체에 어노테이션을 추가할 때
- 고유한 접두사(prefix)를 사용하지 않으면 실수로 서로의 어노테이션을 덮어쓸 수 있음

2\. **관리 용이성**
- 어노테이션의 출처를 명확히 파악 가능
- 도메인별로 어노테이션 그룹화 가능





# 어노테이션을 볼륨으로 추출

downard API 를 이용하면 어노테이션을 볼륨으로 노출할 수 있습니다. 이 경우 다음과 같은 특징들을 만족하게 됩니다.

- (1) 어노테이션 변경시 downard API 로 지정한 해당 파일 자동 업데이트
- (2) Pod 는 항상 annotation 의 최신 변경사항, 파일로 추출한 annotation 의 최신 변경사항을 볼수 있다.

- (3) 어노테이션은 볼륨으로는 추출 가능하지만, 환경변수로는 노출할수 없습니다.



<br/>



**(1) 어노테이션 변경시 downard API 로 지정한 해당 파일 자동 업데이트**

```yaml
# Pod 정의
volumes:
- name: downward
  downwardAPI:
    items:
    - path: "annotations"        # /etc/downward/annotations 파일
      fieldRef:
        fieldPath: metadata.annotations
```

**동작 방식:**

1. Pod에 어노테이션 추가/수정: `kubectl annotate pod my-pod key=value`
2. Kubernetes가 `/etc/downward/annotations` 파일을 **자동으로 업데이트**
3. Pod 내부의 프로세스는 파일을 다시 읽어서 최신 값 확인 가능

**중요:** 환경 변수는 이렇게 자동 업데이트가 불가능합니다!<br/>



**(2) Pod 는 항상 annotation 의 최신 변경사항, 파일로 추출한 annotation 의 최신 변경사항을 볼수 있다.**

✅ Annotation의 최신 변경사항을 볼 수 있음

✅ 파일의 최신 변경사항을 볼 수 있음

✅ 두 가지가 동기화됨 (Annotation 변경 → 파일 자동 업데이트)

e.g.

```bash
# 1. 초기 상태
$ kubectl exec my-pod -- cat /etc/downward/annotations
owner="alice"

# 2. 어노테이션 변경
$ kubectl annotate pod my-pod owner=bob --overwrite

# 3. 파일 내용 자동 업데이트 (Pod 재시작 불필요!)
$ kubectl exec my-pod -- cat /etc/downward/annotations
owner="bob"
```

<br/>



**(3) 어노테이션은 볼륨으로는 추출 가능하지만, 환경변수로는 노출할수 없습니다.**

책에서는 다음과 같이 설명합니다.

```
"Because environment variable values can't be updated afterward, if the labels or annotations of a pod were exposed through environment variables, there's no way to expose the new values after they're modified."
```

**이유:**

- 환경변수는 **컨테이너 시작 시 한 번만 설정**됨
- 이후 변경 불가능
- Labels/Annotations는 **실행 중에도 변경 가능**
- 따라서 환경변수로 노출하면 업데이트된 값을 반영할 방법이 없음



환경변수로 노출 가능 여부 비교

| 메타데이터      | 환경변수 | downwardAPI 볼륨 (파일) |
| --------------- | -------- | ----------------------- |
| Pod 이름        | ✅ 가능   | ✅ 가능                  |
| Pod IP          | ✅ 가능   | ✅ 가능                  |
| Namespace       | ✅ 가능   | ✅ 가능                  |
| Node 이름       | ✅ 가능   | ✅ 가능                  |
| Service Account | ✅ 가능   | ✅ 가능                  |
| CPU requests    | ✅ 가능   | ✅ 가능                  |
| CPU limits      | ✅ 가능   | ✅ 가능                  |
| Memory requests | ✅ 가능   | ✅ 가능                  |
| Memory limits   | ✅ 가능   | ✅ 가능                  |
| **Labels**      | ❌ 불가능 | ✅ 가능                  |
| **Annotations** | ❌ 불가능 | ✅ 가능                  |

<br/>



# e.g. (1)

```bash
$ kubectl exec downward cat /etc/downward/annotations
key1="value1"
key2="multi\nline\nvalue\n"
kubernetes.io/config.seen="2016-11-28T14:27:45.664924282Z"
kubernetes.io/config.source="api"
```

(1) 사용자가 추가한 어노테이션

- `key="value1"`
- 간단한 한줄로 표시

<br/>



(2) 멀티라인 어노테이션

- `key2="multi\nline\nvalue\n"`

실제 모습은 다음과 같은 모양인데 개행문자로 한줄에 표시한 것입니다.

```yaml
annotations:
  key2: |
    multi
    line
    value
```

<br/>



(3) kubernetes 가 자동으로 추가한 어노테이션

```bash
kubernetes.io/config.seen="2016-11-28T14:27:45.664924282Z"
kubernetes.io/config.source="api"
```

- 시스템이 자동으로 추가한 메타정보를 의미합니다.

<br/>



# e.g. (2)

기본

```yaml
metadata:
  annotations:
    owner: "alice"
    team: "backend"
    description: "User authentication service"
```

<br/>



실제 파일 내용(`/etc/downward/annotations`)은 다음과 같이 표시됩니다.

```plain
owner="alice"
team="backend"
description="User authentication service"
```

<br/>



# e.g. (3)

```yaml
metadata:
  annotations:
    description: |
      This is a multi-line
      description of the pod
      that spans multiple lines
```

<br/>



실제 파일 내용 (`/etc/downward/annotations`)에는 다음과 같이 표시됩니다.

```yaml
description="This is a multi-line\ndescription of the pod\nthat spans multiple lines\n"
```

<br/>



# e.g. (4)

```yaml
metadata:
  annotations:
    config: '{"port": 8080, "debug": true}'
    url: "https://example.com/api?key=value"
```

<br/>



실제 파일 내용 (`/etc/downward/annotations`)에는 다음과 같이 표시됩니다.

```plain
config="{\"port\": 8080, \"debug\": true}"
url="https://example.com/api?key=value"
```











