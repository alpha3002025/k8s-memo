# 3.8. pod 삭제, 정지 

> 이번 내용은 Claude 의 도움을 받아 요약했습니다.



주요 Pod 삭제 명령어들

- 이름으로 삭제: `kubectl delete po <name>`
- 레이블로 삭제: `kubectl delete po -l <label>`
- 모두 삭제: `kubectl delete po --all`
- 네임스페이스 삭제: `kubectl delete ns <namespace>`
- 모든 리소스 삭제: `kubectl delete all --all`



Pod 종료 프로세스

- SIGTERM → Grace Period → SIGKILL
- Pre-stop hook을 통한 정리 작업
- Termination Grace Period 설정 가능



참고로 SIGKILL 신호와 SIGTERM 신호의 차이점은 다음과 같습니다.

**Exit Code 137**: 128 + 9 (SIGKILL)

- 프로세스가 강제로 종료됨
- Grace period 내에 종료되지 않았음을 의미

**Exit Code 143**: 128 + 15 (SIGTERM)

- SIGTERM 신호에 의해 종료됨
- 정상적인 종료 신호



Pod 의 삭제/정지 시 내부 동작 원리

- API Server의 중앙 조정
- Kubelet의 컨테이너 종료
- Endpoints Controller의 라우팅 업데이트
- 병렬 프로세스와 타이밍 이슈



모범 사례

- SIGTERM 핸들러 구현
- 적절한 Grace Period 설정
- Pre-stop Hook 활용
- Readiness Probe와 함께 사용



# 삭제 시 주요 메커니즘

Pod가 삭제될 때 클러스터 전체에서 일어나는 복잡한 프로세스를 이해하는 것이 중요합니다.

**주요 컴포넌트:**
- API Server: 클러스터 상태를 관리하는 중앙 컴포넌트
- Kubelet: 각 워커 노드에서 컨테이너를 관리하는 에이전트
- Endpoints Controller: Service의 엔드포인트를 관리
- kube-proxy: 각 노드에서 네트워크 규칙을 관리

**병렬 프로세스:**

```
사용자
  ↓
Delete Pod 요청
  ↓
API Server
  ↓ (알림)
  ├─────────────────┬─────────────────┐
  ↓                 ↓                 ↓
시퀀스 A          시퀀스 B          
(Kubelet 경로)    (Endpoints 경로)
```

**시퀀스 A - 컨테이너 종료:**
1. **A1**: API 서버 → Kubelet에 Pod 삭제 알림
2. **A2**: Kubelet이 컨테이너 중지 프로세스 시작
   - Pre-stop hook 실행 (있는 경우)
   - SIGTERM 신호 전송
   - Grace period 대기
   - SIGKILL로 강제 종료 (필요시)

**시퀀스 B - 네트워크 라우팅 업데이트:**
1. **B1**: API 서버 → Endpoints Controller에 Pod 삭제 알림
2. **B2**: Endpoints Controller가 Service에서 Pod를 엔드포인트로부터 제거
3. **B3**: API 서버 → kube-proxy들에게 엔드포인트 수정 알림
4. **B4**: 각 노드의 kube-proxy가 iptables 규칙 업데이트
   - Pod로의 새 연결 차단
   - 기존 연결은 영향 없음

**중요한 특징:**
- 두 시퀀스는 **병렬로 진행**됩니다
- 각 컴포넌트는 별도의 프로세스/머신에서 실행됩니다
- 모든 컴포넌트가 동기화되는 데 시간이 걸립니다
- 타이밍 이슈가 발생할 수 있습니다

**실전 시사점:**
- Pod 종료 시 일시적으로 "Connection Refused" 오류 발생 가능
- Readiness probe로 이 문제를 완화할 수 있습니다
- Grace period를 적절히 설정해야 합니다








<br/>



# Pod 종료 프로세스

Pod 종료 프로세스는 다음과 같이 이뤄집니다.

- SIGTERM → Grace Period → SIGKILL
- Pre-stop hook을 통한 정리 작업
- Termination Grace Period 설정 가능



예를 들어 다음과 같은 명령을 통해 Pod 종료를 수행하는 경우가 있습니다.

```bash
# Grace period를 5초로 설정
$ kubectl delete po mypod --grace-period=5
```

<br/>



이 경우 다음과 같은 동작이 발생합니다.

- Pre-stop hook 이 미리 설정되어 있는 경우 완료될 때까지 대기합니다.
- Pod 을 종료하려고 할때 Container 의 메인 프로세스에는 SIGTERM 신호가 전송됩니다. 
- `--grace-period=5` 에 지정한 시간 만큼을 프로세스가 깨끗하게 종료되기 까지를 기다립니다. `--grace-period` 의 기본값은 30초입니다.
- 그리고 해당 프로세스가 `--grace-period` 안에 종료되지 않으면 `SIGKILL` 신호를 통해 강제 종료를 수행합니다.



```bash
시작                                    Termination Grace Period                     종료
  |                                              |                                    |
  v                                              v                                    v
[Pre-stop hook] → [SIGTERM 전송] → [애플리케이션 종료 대기...] → [SIGKILL (필요시)]
```

요약해보면 다음과 같습니다.

1. **Pre-stop Hook 실행** (선택사항)
   - 설정된 경우 먼저 실행됩니다
   - 완료될 때까지 대기합니다
   - 정리 작업이나 알림 전송 등에 사용

2. **SIGTERM 신호 전송**
   - 컨테이너의 메인 프로세스에 전송
   - "이제 종료 준비를 해주세요"라는 의미
   - 애플리케이션이 graceful shutdown 수행

3. **Termination Grace Period**
   - 기본값: 30초
   - 프로세스가 깨끗하게 종료되기를 대기
   - 설정 가능한 시간

4. **SIGKILL 신호** (최후의 수단)
   - Grace period 내에 종료되지 않으면 실행
   - 즉시 강제 종료
   - 차단할 수 없는 신호



<br/>



## 참고) SIGKILL 신호와 SIGTERM 신호의 차이점

SIGKILL 신호와 SIGTERM 신호의 차이점은 다음과 같습니다.

**Exit Code 137**: 128 + 9 (SIGKILL)

- 프로세스가 강제로 종료됨
- Grace period 내에 종료되지 않았음을 의미

**Exit Code 143**: 128 + 15 (SIGTERM)

- SIGTERM 신호에 의해 종료됨
- 정상적인 종료 신호



<br/>



## Grace Period 설정 방법들

### Pod yaml 정의를 통해 설정하는 방법

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-app
spec:
  terminationGracePeriodSeconds: 15  # 15초로 설정
  containers:
  - name: app
    image: my-app:latest
```



### kubectl 명령어 옵션으로 지정

Graceful period 를 5초로 지정

```bash
# Grace period를 5초로 설정
$ kubectl delete po mypod --grace-period=5
```

<br/>



즉시삭제

```bash
# Grace period 0 + force 옵션
$ kubectl delete po mypod --grace-period=0 --force
```

보통 `--grace-period` 를 지정하지 않으면 30s(30초)로 지정되는데, 즉시 설정하고 싶다면 `--force` 를 통해 지정하면 됩니다.

<br/>



강제 삭제는 위험하기 때문에 가급적 다음 사항에 해당할 경우에 위의 강제삭제를 고려할수 있습니다.

- 노드가 완전히 실패했음을 확인한 경우
- 노드가 네트워크에서 분리되어 재연결 불가능한 경우
- Pod가 더 이상 실행되지 않음을 확실히 알 수 있는 경우



<br/>



⚠️ **StatefulSet의 Pod에는 특히 주의**

상태를 가지는 파드의 그룹인 StatefulSet으로 운영 시에 Pod 삭제시 다음의 side effect 가 발생할 수 있습니다.

StatefulSet Controller는 동일한 Pod의 두 인스턴스가 동시에 실행되지 않도록 보장하는데, 강제 삭제 시 이 보장이 깨집니다. 이런 이유로 다음과 같은 현상이 발생할 수 있습니다.

- 같은 ordinal index를 가진 Pod 2개가 동시 실행
- 같은 PersistentVolume에 동시 접근
- Stateful 클러스터 오작동 가능



> statefulset 은 일반적으로 사용하지는 않지만, 개발을 위한 임시 DB 용도로 mysql 을 pod 로 구동한다거나 하는 경우 내부를 확인해보면 statefulset 으로 구동되는 경우가 많습니다.

<br/>



# Graceful Shutdown 모범 사례

## Pre-stop Hook 

**HTTP GET 방식:**

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-app
spec:
  containers:
  - name: app
    image: my-app:latest
    lifecycle:
      preStop:
        httpGet:
          path: /shutdown
          port: 8080
  terminationGracePeriodSeconds: 30
```

<br/>



**Command 실행 방식:**

책에서 제공하고 있는 예제는 아마도 nginx 가 포함된 이미지에 대한 예제로 보입니다.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-app
spec:
  containers:
  - name: app
    image: my-app:latest
    lifecycle:
      preStop:
        exec:
          command: ["/bin/sh", "-c", "nginx -s quit; while killall -0 nginx; do sleep 1; done"]
  terminationGracePeriodSeconds: 30
```

`/bin/sh -c "nginx -s quit; while killall -0 nginx; do sleep 1; done"`

- `/bin/sh -c`

  - **쉘을 실행**하여 뒤따라오는 명령어를 실행합니다
  - `-c` 옵션: 문자열로 전달된 명령어를 실행

- `nginx -s quit`
  - `-s` : signal 옵션
  - `quit` : graceful shutdown (SIGQUIT 신호)
  - 새로운 연결 수락을 중단합니다. 현재 처리중인 요청들을 모두 완료할 때 까지 기다립니다.
  - 모든 요청 처리가 끝나면 nginx 프로세스를 종료합니다.

- `;` (세미콜론)
  - 명령어 구분자
  - 첫 번째 명령어(`nginx -s quit`)가 완료되면 다음 명령어를 실행

- `while killall -0 nginx; do sleep 1; done`
  - nginx가 완전히 종료될 때까지 대기하는 루프

- `while ... ; do ... ; done`
  - while 루프 구조
  - 조건이 참(true)인 동안 반복 실행

`killall -0 nginx` 에서 -0 옵션의 의미
- 신호를 보내지 않고 프로세스가 존재하는 지만 확인
- nginx 라는 이름의 프로세스가 실행중인지 체크
- exit code = 0 : nginx 프로세스가 존재할 경우
- exit code = 1 : nginx 프로세스가 없을 경우
- `-0` 옵션이 없으면 그대로 종료시킵니다.



위의 Pre stop Hook 은 다음과 같이 동작합니다.

e.g. 5 초간 killall -0 을 통해 체크하면서 종료 수행  (5초 소요)

```bash
시간   상태                           명령어 결과
T+0s   nginx -s quit 실행            → graceful shutdown 시작
T+0s   killall -0 nginx              → exit 0 (프로세스 존재)
T+0s   sleep 1                       → 1초 대기
T+1s   killall -0 nginx              → exit 0 (아직 요청 처리 중)
T+1s   sleep 1                       → 1초 대기
T+2s   killall -0 nginx              → exit 0 (요청 처리 중)
T+2s   sleep 1                       → 1초 대기
T+3s   killall -0 nginx              → exit 0 (마지막 요청 처리)
T+3s   sleep 1                       → 1초 대기
T+4s   killall -0 nginx              → exit 0 (종료 진행 중)
T+4s   sleep 1                       → 1초 대기
T+5s   killall -0 nginx              → exit 1 (프로세스 없음!)
T+5s   while 루프 종료               → preStop hook 완료
```



-0 옵션없이 종료시 (1초 소요)

```bash
시간   상태                           명령어 결과
T+0s   nginx -s quit 실행            → 처리 중인 요청 없음
T+0s   nginx 즉시 종료 완료
T+0s   killall -0 nginx              → exit 1 (프로세스 없음)
T+0s   while 루프 즉시 종료          → preStop hook 완료
```

<br/>



## SIGTERM 핸들러

**Node.js 예제:**

```javascript
process.on('SIGTERM', () => {
  console.log('SIGTERM 신호를 받았습니다. Graceful shutdown 시작...');
  
  // 1. 새로운 연결 거부
  server.close(() => {
    console.log('HTTP 서버 종료 완료');
    
    // 2. 데이터베이스 연결 종료
    db.close();
    
    // 3. 진행 중인 작업 완료
    // 4. 정리 작업 수행
    
    console.log('Graceful shutdown 완료');
    process.exit(0);
  });
  
  // 타임아웃 설정 (grace period보다 짧게)
  setTimeout(() => {
    console.error('강제 종료 시간 초과');
    process.exit(1);
  }, 25000); // 25초 (grace period 30초보다 짧게)
});
```

**Python (Flask) 예제:**
```python
import signal
import sys
import time

def signal_handler(sig, frame):
    print('SIGTERM 신호를 받았습니다. Graceful shutdown 시작...')
    
    # 1. 새로운 요청 거부
    # 2. 현재 처리 중인 요청 완료 대기
    time.sleep(5)  # 실제로는 진행 중인 작업 확인
    
    # 3. 리소스 정리
    print('Graceful shutdown 완료')
    sys.exit(0)

signal.signal(signal.SIGTERM, signal_handler)
```

<br/>



## Graceful Period 를 적절하게 설정

- 애플리케이션의 평균 요청 처리 시간
- 진행 중인 작업 완료 시간
- 데이터베이스 연결 종료 시간
- 캐시 플러시 시간



```bash
# 빠른 애플리케이션 (웹 서버 등)
terminationGracePeriodSeconds: 30  # 기본값

# 배치 처리 애플리케이션
terminationGracePeriodSeconds: 300  # 5분

# 데이터베이스
terminationGracePeriodSeconds: 600  # 10분
```



<br/>



# Pod 삭제 명령 수행 시 주요 Best Practice

## Pod 삭제 전 주요 내용 확인

```bash
# 1. Pod 상태 확인
$ kubectl get po

# 2. Pod의 레이블 확인
$ kubectl get po --show-labels

# 3. Pod의 상세 정보 확인
$ kubectl describe po <pod-name>

# 4. Pod의 로그 확인 (필요시 백업)
$ kubectl logs <pod-name> > pod-logs-backup.txt
```

<br/>



## 안전하게 삭제 (namespace, label 활용)

```bash
# 1. 특정 Pod만 삭제
$ kubectl delete po <pod-name>

# 2. 레이블로 선택적 삭제
$ kubectl delete po -l env=test

# 3. 네임스페이스의 모든 Pod 삭제
$ kubectl delete po --all -n <namespace>

# 4. 네임스페이스 전체 삭제
$ kubectl delete ns <namespace>
```

<br/>



## 삭제 전 dry-run 사용

```bash
# 실제로 삭제하지 않고 결과 확인
$ kubectl delete po -l app=myapp --dry-run=client
```

<br/>



## 삭제 대기 시간 지정

```bash
# 삭제 완료까지 대기
$ kubectl delete po <pod-name> --wait=true

# 대기하지 않고 비동기 삭제
$ kubectl delete po <pod-name> --wait=false
```

<br/>



## 삭제 모니터링

```bash
# 삭제 진행 상황 실시간 모니터링
$ kubectl get po -w

# 특정 Pod의 이벤트 확인
$ kubectl get events --field-selector involvedObject.name=<pod-name>
```

<br/>


# namespace 단위 삭제 예제

## e.g. 전체 네임스페이스를 삭제해서 namespace 내 모든 pod 삭제

```bash
$ kubectl delete ns custom-namespace
namespace "custom-namespace" deleted
```

**자동 리소스 정리:**

- 네임스페이스를 삭제하면 그 안의 모든 Pod가 **자동으로 함께 삭제**됩니다
- 네임스페이스 내의 모든 리소스(Services, ConfigMaps, Secrets 등)도 함께 삭제됩니다

**사용 시나리오:**

- 개발/테스트 환경 전체를 정리할 때
- 특정 프로젝트나 팀의 모든 리소스를 한 번에 제거할 때
- 네임스페이스와 그 안의 모든 리소스를 한 번에 정리하는 가장 간단한 방법

**주의사항:**
- 복구가 불가능하므로 신중하게 사용해야 합니다
- 프로덕션 네임스페이스는 특히 주의해서 다뤄야 합니다



## e.g. 네임스페이스는 유지하면서 모든 pod 삭제

```bash
$ kubectl get pods
NAME           READY   STATUS    RESTARTS   AGE
kubia-zxzij    1/1     Running   0          1d

## 모든 pod 삭제 시도
$ kubectl delete po --all
pod "kubia-zxzij" deleted

## Pod 를 삭제하더라도 살아나는 경우 : Deployment 또는 ReplicationController 에 의해 재생성
$ kubectl get pods
NAME           READY   STATUS        RESTARTS   AGE
kubia-09as0    1/1     Running       0          1d
kubia-zxzij    1/1     Terminating   0          1d
```

**자동 복구 메커니즘:**

- ReplicationController가 관리하는 Pod를 삭제하면
- ReplicationController가 즉시 새로운 Pod를 생성합니다
- 지정된 replica 수를 유지하기 위함입니다

**완전한 삭제 방법:**
Pod를 완전히 삭제하려면 **ReplicationController도 함께 삭제**해야 합니다. 이는 다음 섹션(3.8.5)에서 다룹니다.



## e.g. 네임스페이스의 (거의) 모든 리소스 삭제

```bash
$ kubectl delete all --all
pod "kubia-09as0" deleted
replicationcontroller "kubia" deleted
service "kubernetes" deleted
service "kubia-http" deleted
```

1. **첫 번째 `all`**:
   - 모든 **타입**의 리소스를 대상으로 함
   - Pods, Services, ReplicationControllers, Deployments 등

2. **`--all` 옵션**:
   - 각 타입의 **모든 인스턴스**를 삭제함
   - 이름을 지정하지 않고 전체 삭제



## 주요 제한사항

1\. "all"이 절대적으로 모든 것을 삭제하지는 않음

**보존되는 리소스:**
- **Secrets**: 민감한 정보를 담고 있어 명시적으로 삭제해야 함
- **ConfigMaps**: 일부는 보존될 수 있음
- **PersistentVolumeClaims**: 데이터 보호를 위해 보존됨
- 기타 특수 리소스들

**완전한 삭제가 필요한 경우:**
```bash
$ kubectl delete secrets --all
$ kubectl delete configmaps --all
$ kubectl delete pvc --all
```
<br/>



2\. kubernetes Service의 재생성

- `kubectl delete all --all` 명령은 `kubernetes` Service도 삭제합니다
- 하지만 이 기본 Service는 **자동으로 재생성**됩니다
- 일반적으로 몇 초 내에 복구됩니다



# Pod 삭제/종료 시 Troubleshooting

## Pod 이 삭제되지 않을때

증상 확인

```bash
$ kubectl delete po mypod
# Pod가 Terminating 상태에서 멈춤
```



가능한 원인들

- Finalizer 문제
- PVC 연결 문제
- Node 통신 문제



Finalizer 문제일 경우

```bash
# Finalizer 확인
$ kubectl get po mypod -o yaml | grep finalizers -A 5

# Finalizer 제거 (주의!)
$ kubectl patch po mypod -p '{"metadata":{"finalizers":null}}'
```



PVC 연결 문제일 경우

```bash
# PVC 상태 확인
$ kubectl get pvc

# PVC가 Released 또는 Terminating 상태면 삭제
$ kubectl delete pvc <pvc-name> --grace-period=0 --force
```



노드 통신 문제일 경우

```bash
# 노드 상태 확인
$ kubectl get nodes

# 노드가 NotReady 상태면 Pod 강제 삭제 고려
$ kubectl delete po mypod --grace-period=0 --force
```

<br/>



## 삭제 후 Pod 가 계속 생성되는 경우

**원인:**

- ReplicationController, ReplicaSet, Deployment가 Pod를 관리하고 있음



**해결**

```bash
# 관리하는 컨트롤러 확인
$ kubectl get all

# 컨트롤러 삭제
$ kubectl delete deployment <deployment-name>
# 또는
$ kubectl delete rs <replicaset-name>
# 또는
$ kubectl delete rc <replicationcontroller-name>
```

<br/>



## 네임스페이스가 삭제되지 않는 경우

**증상:**

```bash
$ kubectl delete ns my-namespace
# 네임스페이스가 Terminating 상태에서 멈춤
```

**해결:**
```bash
# 1. 네임스페이스의 모든 리소스 확인
$ kubectl get all -n my-namespace

# 2. API 리소스 목록 확인
$ kubectl api-resources --verbs=list --namespaced -o name | xargs -n 1 kubectl get --show-kind --ignore-not-found -n my-namespace

# 3. Finalizer 제거 (최후의 수단)
$ kubectl get ns my-namespace -o json > temp.json
# temp.json 파일에서 finalizers 섹션 제거 후
$ kubectl replace --raw "/api/v1/namespaces/my-namespace/finalize" -f ./temp.json
```









